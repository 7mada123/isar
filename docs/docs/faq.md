---
title: FAQ
---

# Frequently Asked Questions

A random collection of frequently asked questions about Isar and Flutter databases.

### Why do I need a database?

> I store my data in a backend database, why do I need Isar?.

Even today, it is very common to have no data connection, if you are in a subway or in a plane, or if you visit your grandma who has no WiFi and very bad cell signal. You shouldn't let bad signal cripple your app!

### Isar vs Hive

The answer to this one is easy: do you have structured data or do you want to query your data? Use Isar. For dynamic data or very simple use cases, you can use Hive.

### Isar

> How much data can be stored and handled by Isar?

That highly depends on the your objects, your indexes and which queries you want to run ðŸ™‚ everything in the low millions should be fine

Keep in mind though that you cannot store more data than the virtual (!) memory of your device. That's the same restriction that realm and objectbox also have

> How Isar works?

Isar has multiple parts:

[Isar Generator](https://github.com/isar/isar/tree/main/packages/isar_generator) handles everything related to code generation, using [build_runner](https://pub.dev/packages/build_runner). It basically takes the collection classes that you declared, and generates a schema object and all kinds of extension methods that will help you easily perform queries. In theory you don't have to use the generator, you could probably make the schema by hand, by it would be way more difficult and way more error prone.

[Isar](https://github.com/isar/isar/tree/main/packages/isar) is the front facing api. It is basically an interface for the platform code (js / native). It is using this package that you will be able to create an isar instance, register your collection's schema and execute CRUD operations.
Extension methods generated by Isar Generator and uses the buildQuery method from this package in order to simplify queries and add typings.

Isar uses Dart SendPorts and ReceivePorts to get around the â€žffi cannot be asyncâ€œ limitation. Through transactions, every single ffi method can be either called synchronously or asynchronously.

[Isar Core](https://github.com/isar/isar-core) is where the actual data handling is done. It is written is rust, which allows for great safety and performance. Internally, it uses [Libmdbx](https://libmdbx.dqdkfa.ru/), a fork of LMDB) to store the data.
In order to allow you app to communicate with the native code, dart's built-in ffi is used.
Isar Core uses a custom data format with a few cool attributes: 
- it is fully backwards compatible with added or removed fields
- it is extremely space efficient 
- it has zero cost migration between schema versions
- it allows random access.
This last one is especially important for queries because not the entire object needs to be parsed to access a single property.

Because of the special format it is almost impossible to use Isar Core without the isar generator currently. There are some strict requirements that the generator takes care of.

For reading, Isar Core does not need to copy your data even once. Mdbx uses memory mapping and the memory mapped object is served directly to the Dart code where it gets decoded.

Isar Core has a very fast query system with support for advanced composite indexes. Some of its speed it gets through static dispatch . Same for aggregation.


[Isar Web](https://github.com/isar/isar-web) is similar to Isar Core, but is used for the web target. It uses the IndexedDB api to store the data.

### Benchmarks

> I saw this one benchmark where database X was faster than Isar.

Database performance is very dependent on the use case. Most benchmarks just dump 10000 records into the database and then read them back. That will almost never happen in real life.  
Isar is extremely fast and has a few unique tricks to allow you to write much faster queries than with databases that look faster in benchmarks (like composite and multi-entry indexes, FTS etc.).

Some databases don't even support asynchronous access and require you to either run all operations in a separate isolate or block your UI isolate.

Benchmarks only give a rough idea of the performance of a database but as you can see, Isar NoSQL database is quite fast ðŸ˜‡

<img src="https://raw.githubusercontent.com/isar/isar/main/.github/assets/benchmarks/insert.png" width="100%" /> | <img src="https://raw.githubusercontent.com/isar/isar/main/.github/assets/benchmarks/query.png" width="100%" />
--- | ---
<img src="https://raw.githubusercontent.com/isar/isar/main/.github/assets/benchmarks/delete.png" width="100%" /> | <img src="https://raw.githubusercontent.com/isar/isar/main/.github/assets/benchmarks/size.png" width="100%" />

If you are interested in more benchmarks or want to check how Isar performs on your device you can run the [benchmarks](https://github.com/isar/isar_benchmark) yourself.


### Where clauses?!

> Why do **_I_** have to choose which index to use?

There are multiple reasons. Many databases use heuristics to choose the best index for a given query. The database needs to collect additional usage data (-> overhead) might still choose the wrong index. It also makes creating a query slower.

Nobody knows your data better than you, the developer. So you can choose the optimal index and decide for example whether you want to use an index for querying or sorting.

### Do I have to use indexes / where clauses?

Nope! Isar is often fast enough if you only rely on filters.

### Does Isar increase the size of my app?

A little bit, yes. Isar will increase the download size of your app about 1 - 1.5 MB. Isar Web only a few KB.

### The docs are incorrect / there is a typo.

Oh no, sorry. Please [open an issue](https://github.com/isar/isar/issues/new/choose) or even better a [PR](https://github.com/isar/docs) to fix it ðŸ’ª.
